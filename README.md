# DaduGo

# 说明
这是一个用Python编写的简易的围棋第三方库，包含围棋的规则和一个GUI.

# API
### GoBoard
`GoBoard`是由二维列表组成的，其中每一个子列表都代表围棋棋盘中的一行。当围棋棋盘中的某一坐标为空，即没有棋子时，`GoBoard`类对应的元素值为0。其余情况下，`GoBoard`中的元素对应一个`Stone`对象。
```
# 19 * 19 的空围棋盘
[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
```
### Stone
`Stone`是由一个棋盘坐标，i.e. 一个以 `(x,y)` 作为形式的元组, 一种颜色属性, i.e. 黑(`"black"`)
或 白(`"white"`), 和一个`GoBoard`组成的。
```
# 创建一个Stone对象
board = GoBoard()
stone = Stone((0,0), "black", board)
```
### BlockStone
`BlockStone`是由一个`GoBoard`和一个`Stone`对象组成的。它代表了在这个`GoBoard`棋盘上和这个`Stone`对象全局紧邻的所有`Stone`对象的集合。我们定义一个`GoBoard`中的有效位移为一个坐标到其正上方、正下方、正左、或正右的位移。我们定义当且仅当一个`Stone`对象的坐标能通过有限次有效位移到达另一个具有相同颜色属性的`Stone`对象的坐标时，这两个`Stone`对象具有全局紧邻关系。特别地，我们定义当且仅当一个`Stone`对象的坐标能通过1次有效位移到达另一个具有相同颜色属性的`Stone`对象的坐标时，这两个`Stone`对象具有局部紧邻关系。
### GameLogic
`GameLogic`是由一个所有元素皆为0的`GoBoard`对象组成的。它代表了一个围棋对局。
```
# 创建一个围棋对局
new_game = GameLogic(GoBoard())
```
### `board.reset_board()`
- `board: GoBoard`

重制整个棋盘使其成为空棋盘。
### `board.num_stones()`
- `board: GoBoard`

返回当前棋盘上的棋子数量。
### `stone.adjacent_stones()`
- `stone: Stone`

更新该`Stone`对象的局部紧邻关系表，可通过`stone.adjacent`查看。`stone.adjacent`是由一个一维列表组成的，其中第1、2、3、4个元素分表代表了该`Stone`对象在棋盘上正上、正下、正左、正右方的元素。如果该元素为0，则代表该`Stone`对象上方没有棋子；如果该元素为一个具有相同元素属性的`Stone`对象，那么它们由局部紧邻关系; 如果该元素不存在，即`Stone`对象处于棋盘边界位置时，该元素值被代表为-2。
### `block.find_block_stone()`
- `block: BlockStone`

返回一个和该`Stone`对象全局紧邻的所有`Stone`对象的集合。
### `block.has_empty_adjacency()`
- `block: BlockStone`

判断这个`BlockStone`对象是否有气（围棋术语）。
### `new_game.step`
- `new_game: GameLogic`

返回当前棋盘已落子数目。
### `new_game.record`
- `new_game: GameLogic`

返回一个一维列表，其中第1, 2, 3, ... , n 个元素分别代表了该棋局中自当前手术前 n, ... , 3, 2, 1步棋时的`GoBoard`对象。如果该棋局手术不足3手，则一维列表中的元素依次递减。
### `new_game.move(stone)`
- `new_game: GameLogic`
- `stone: Stone`

如果这是合理的一手棋，则更新该`Stone`对象到棋盘中的相应坐标处，并更新棋盘中有可能发生的提子（围棋术语）现象，并且返回真值。如果这不是合理的一手棋，则返回否值。当一个`Stone`对象被提起时，更新棋盘相应坐标中的元素为0。

我们说一步棋是合理的，当且仅当这步棋满足以下4点:
-   这步棋落在了棋盘坐标上。
-   这步棋没有落在另一枚棋子上。
-   这步棋没有下在禁入点（围棋术语），或者这步棋下出会发生提子（围棋术语）现象。
-   这步棋没有造成全局重复，即同样的围棋局面再次出现。
# 准备
你需要下载一些python第三方库以运行游戏。你可以在`requirement.txt`里看到这些下载要求。

如果你想创建虚拟环境，则在根路径运行以下命令:
```
python3 -m venv venv
```
运行以下命令以激活该虚拟环境:
```
source venv/bin/activate
```
运行以下命令以下载需要安装的第三方库:
```
pip3 install -r requirement.txt
```
运行以下命令以解除该虚拟环境:
```
deactivate
```

# GUI
在根路径运行以下命令以运行游戏：
```
python3 logic/pygame_gui.py
```

# 补充说明
敬请期待其他更新！